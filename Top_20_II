0. What is Lifting State Up in React?
Lifting State Up is a concept in React where you move the shared state of multiple components to a common parent component, which then becomes the single source of truth for that state. This allows you to manage and synchronize the state changes across different components more effectively.

When you have multiple components that need to share and update the same data, it's often a good idea to lift that shared state up to a common ancestor component. This ensures that the data remains consistent and avoids situations where different components have their own copies of the same data, leading to synchronization issues.

Benefits of Lifting State Up:

Single Source of Truth: By lifting the state to a common parent component, you ensure that there is only one place where the data is stored and updated. This reduces the chances of inconsistencies.

Improved Data Flow: Lifting state up simplifies the data flow between components. Child components receive the state data as props from the parent and communicate state changes back to the parent through callback functions.

Easier Debugging: When the state is managed in a centralized manner, it becomes easier to debug and trace the flow of data and changes.

Reusability: Lifting state up promotes the creation of more reusable and modular components, as they can access and modify shared state without duplicating it.

Example Scenario:
Imagine you have a form with multiple input fields, and you want to display and update the form data in different parts of your application. Instead of managing the form data separately in each component that uses it, you can lift the form data state to a higher-level parent component. This parent component manages the form data and passes it down to the child components as props. When a user interacts with the form inputs, the child components notify the parent component to update the form data, which then triggers a re-render of the child components with the updated data.

Lifting State Up is a fundamental principle in React's approach to managing state and building maintainable and scalable applications. It promotes better data flow, reusability, and consistency across components.


1. What is React context?

React Context is a feature in the React library that allows you to share state or data between components without the need to pass props through multiple levels of component hierarchy. It provides a way to share data that can be considered "global" for a tree of React components, eliminating the need to manually pass props down from parent to child components.

With React Context, you can create a "context" object that holds the data you want to share. This context object can then be accessed by any component within its defined scope, regardless of how deeply nested that component is in the component tree.

React Context is particularly useful for scenarios where you have data that many components need to access, such as user authentication status, themes, and localization settings. It simplifies the process of managing and sharing this kind of data, making your component code cleaner and more maintainable.

Here's a basic example of how React Context works:

Create a Context: You define a context using the React.createContext() function.

Provide the Context: Wrap the components that need access to the context data within a <Context.Provider> component. This provides the data to those components.

Consume the Context: Use the useContext hook (or the Context.Consumer component) to access the context data within your components.


2. What are different ways to add CSS in your app?
1 - External Stylesheet
You can create a new CSS file in your project directory and add your CSS inside it. It can then be imported into your React component or class. The following code is used to import an external CSS stylesheet.

import "./styles.css";
2 - Inline CSS
Inline CSS is perhaps the most common and quick method to add styles in React. However, it has several drawbacks and is generally discouraged, especially for larger applications.

To implement inline CSS, you can create an object containing style references, which can be then called using the style{} attribute. For example:

const styles = {
  section: {
    fontSize: "18px",
    color: "#292b2c",
    backgroundColor: "#fff",
    padding: "0 20px"
  },
  wrapper: {
    textAlign: "center",
    margin: "0 auto",
    marginTop: "50px"
  }
}
It is then added to an element like this:

<section style={styles.section}>
  <div style={styles.wrapper}>
  </div>
</section>
3 - Styled Components
Probably the most powerful and useful in my opinion is Styled Components. Styled Components lets you write actual CSS in your JavaScript. The main advantage is that you can add conditional code and use variables and functions within the CSS.

You can install Styled Components using the following command:

npm install --save styled-components
Next, you need to import it into your component. Then you can create a new variable that will contain the CSS. The same variable name can be used to an HTML element with the previously added styles on it.

import styled from 'styled-components'
// Create a button variable and add CSS
const Button = styled.button`
  background: transparent;
  border-radius: 3px;
  border: 2px solid red;
  color:red;
`
//display the HTML
return (
  <div>
    <Button>Button</Button>
  </div>
);
4 - CSS Modules
You can also add scoped styles quite easily, you just need to create a file with the extension .module.css, like this:

// ComponentName.module.css

.Red {
  color: #f00;
}

.Blue {
  color: #00f;
}
Then you import it like this:

import styles from "./ComponentName.module.css";
and use it like this:

<span className={styles.Red}>This text will be red</span>
<span className={styles.Blue}>This text will be blue</span>
5 - Atomic CSS
One of the most popular atomic CSS frameworks out there is Tailwind, by just making it part of your project following their instructions you can just use classNames without even touching CSS.

<button className="font-bold bg-blue-600 px-6 py-3 text-white rounded-md">Blue button</button>
6 - Emotion
Styled-components is not the only library that allows you to create components with styles embedded on them, you have great alternatives out there such as Emotion. The best thing about Emotion is that it's framework agnostic, so you can take your knowledge to other libraries and frameworks besides React, while being pretty similar to styled-components (so you can in several scenarios just change the import).


3. What is Hot Module Replacement?
Hot Module Replacement (HMR) is a feature in modern web development frameworks, such as React, Vue.js, and webpack, that allows developers to update code in real-time without requiring a full page reload. It significantly speeds up the development process by enabling you to see immediate changes to your code without losing the application's state.

Here's how Hot Module Replacement works:

Detecting Changes: During development, when you make changes to your code files (such as JavaScript, CSS, or templates), the development server detects those changes.

Hot Patching: Instead of reloading the entire page, HMR applies the updated code for the changed module dynamically, "hot patching" the running application.

Preserving State: HMR preserves the application's current state, including variables, component states, and other runtime data. This means you can see your changes instantly without losing the context of your application.

Fast Feedback Loop: HMR reduces the need to manually trigger a page refresh or re-navigate through the application to see changes. This results in a faster development feedback loop and increased productivity.

For example, if you're developing a React application and you modify a component's code, HMR will automatically update the component on the page without causing a full page reload. This allows you to immediately see the effect of your changes and make adjustments more efficiently.

Keep in mind that while HMR is a powerful tool for improving development speed, it might not handle all types of changes seamlessly. Some complex changes or changes deep within the component tree might still require a full page reload. Additionally, the setup of HMR might vary depending on the framework or build tools you are using.

In summary, Hot Module Replacement is a developer productivity tool that enhances the development experience by enabling real-time code updates, preserving application state, and reducing the need for manual page refreshes during development.

4. What is the use of Parcel, Vite, Webpack?
5. How does create-react-app work?

6. What is Tree Shaking?
7. Difference b/w dependency and devDependency
8. What is npx and npm?
9. Difference b/w package .json and package-lock .json
10. Difference between console .log(<HeaderComponent/>) and console .log(HeaderComponent());

11. What is React.Fragment?
12. What is the purpose of dependency array in useEffect? What is the difference when it is used and when it is not used?
13. What if 2 components are given will the state change in one component will effect the other component’s state (child)?
14. What is the use of return in useEffect ?
15. Difference b/w client-side routing and server-side routing?

16. Explain the concept of code splitting and its benefits in React.
17. How does React handle routing and navigation?
18. What are higher-order components (HOC) in React?
19. What are controlled and uncontrolled components?
20. Explain the concept of reconciliation in React.
